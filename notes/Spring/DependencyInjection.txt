Dependency Injection

* Dependency Injection là một kỹ thuật nâng cao của OOP.
abstraction = service = interface
class = component = implementation

I. Tổng quan về Dependency Injection
1. What? Why? How?
- Dependency Injection (DI) là một tập hợp các nguyên tắc và mẫu thiết kế phần mềm cho phép bạn tạo ra mã “loosely coupled” (trong “low coupling, high cohension”).
- Khi một đứa trẻ tự lấy đồ trong tủ lạnh, nó có thể gây ra rắc rối như quên đóng cửa tủ, lấy nhầm đồ, tìm kiếm thứ không có trong tủ, lấy phải đồ hết hạn, v.v. Thay vào đó, đứa trẻ nên nói cho bố mẹ biết nhu cầu của mình và họ sẽ đảm bảo đứa trẻ có được thứ nó muốn khi cần. (Các lớp phụ thuộc vào nhau nên dựa vào nền tảng để cung cấp các dịch vụ cần thiết.)
- DI không phải mục tiêu cuối cùng, mà là phương tiện để đạt được nó. Mục tiêu cuối cùng của DI là viết mã có thể bảo trì dễ dàng. DI cho phép loosely coupled (liên kết lỏng lẻo), loosely coupled cho phép mã dễ bảo trì hơn.
Cảnh báo: Program to an interface, not an implementation. (Mã của bạn chỉ nên biết về abstraction, không nên biết về class cụ thể nào sẽ thực sự thực thi logic đó. Điều này làm cho mã dễ mở rộng, dễ bảo trì, và ít bị ảnh hướng khi implementation thay đổi.)
Lưu ý: Nguyên tắc Open/Closed: Trong điều kiện lý tưởng, một yêu cầu mới chỉ cần thêm một lớp mới mà không phải thay đổi các lớp đã tồn tại. (Điều kiện lý tưởng có nghĩa là một hệ thống không bao giờ đạt được 100% open/closed.) 

- Những lầm tưởng phổ biến về DI:
• DI chỉ là liên kết muộn (late binding—xác định implementation thực sự ở thời điểm chạy chứ không phải khi biên dịch, điều này cho phép thay thế một phần của ứng dụng (module, plug-in, thư viện) mà không cần biên dịch lại mã nguồn): late binding là một khía cạnh của DI, nhưng không phải toàn bộ DI đều là về late binding.
• DI chỉ dùng để thực hiện unit testing.
• DI là một loại Abstract Factory cải tiến (Abstract Factory là một abstraction chứa nhiều phương thức, mỗi phương thức trả về một loại đối tượng): Nhiều người nhầm lẫn rằng DI là một Service Locator (một Abstract Factory đa năng). Với DI, bạn không bao giờ chủ động tìm và lấy phụ thuộc từ nơi khác mà bạn sẽ đưa ra yêu cầu với nhà cung cấp để họ cung cấp chúng cho bạn.
Lưu ý: Nếu bạn nhầm lẫn giữa DI và Service Locator thì bạn cũng sẽ sử dụng DI Container như một Service Locator.
Cảnh báo: Không sử dụng DI Container như một Service Locator.
• DI yêu cầu phải có DI Container: DI vẫn có thể thực hiện được mà không cần DI Container, gọi là Pure DI. (DI là một tập hợp các nguyên tắc và mẫu thiết kế, DI Container là một công cụ hỗ trợ việc thực hiện DI.)

- Trong thực tế, yêu cầu của khách hàng thường mơ hồ và dễ dàng thay đổi. Sử dụng DI cho phép bạn viết mã loosely coupled, có thể linh hoạt đáp ứng những thay đổi yêu cầu từ khách hàng.
Lưu ý: Với các ứng dụng vài trăm dòng mã, việc sử dụng DI mang lại cảm giác thiết kế quá mức và làm tăng thêm lượng lớn mã nguồn. Tuy nhiên, khi độ phức tạp tăng lên hàng nghìn, chục nghìn dòng mã thì chi phí xử lý giảm dần và gần như biến mất.

(Đọc đến tr. 49 - Late Binding)